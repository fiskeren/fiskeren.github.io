<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on fiskeren.github.io</title>
        <link>https://fiskeren.github.io/posts/</link>
        <description>Recent content in Posts on fiskeren.github.io</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sat, 29 Oct 2022 17:12:12 +0200</lastBuildDate>
        <atom:link href="https://fiskeren.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Geolocating IP addresses in Velociraptor</title>
            <link>https://fiskeren.github.io/posts/velogeoip/</link>
            <pubDate>Fri, 12 Aug 2022 17:28:43 +0100</pubDate>
            
            <guid>https://fiskeren.github.io/posts/velogeoip/</guid>
            <description>&lt;p&gt;I read the &lt;a href=&#34;http://www.mashthatkey.com/2022/08/velociraptor-playground-2022-08-02.html?m=1&#34;&gt;blog post&lt;/a&gt; by Carlos Cajigas and saw his &lt;a href=&#34;https://www.youtube.com/watch?v=DMj0pU6kYvg&#34;&gt;YouTube&lt;/a&gt; video demonstrating some really neat Velociraptor tricks including usage of the build in &lt;code&gt;geoip()&lt;/code&gt; function, which can be used to enrich artefacts in Velociraptor hunts. This inspired me to write this small blog post where I&amp;rsquo;ll quickly run over how to use &lt;code&gt;geoip()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This could be useful if you for example know hosts normally only connects to IPs located in the US, Ireland and UK and want to spot that specific process that connects to something else, or if you are on the lookout for processes connecting to hosts in a specific country etc - insert your own use case :-)&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>I read the <a href="http://www.mashthatkey.com/2022/08/velociraptor-playground-2022-08-02.html?m=1">blog post</a> by Carlos Cajigas and saw his <a href="https://www.youtube.com/watch?v=DMj0pU6kYvg">YouTube</a> video demonstrating some really neat Velociraptor tricks including usage of the build in <code>geoip()</code> function, which can be used to enrich artefacts in Velociraptor hunts. This inspired me to write this small blog post where I&rsquo;ll quickly run over how to use <code>geoip()</code>.</p>
<p>This could be useful if you for example know hosts normally only connects to IPs located in the US, Ireland and UK and want to spot that specific process that connects to something else, or if you are on the lookout for processes connecting to hosts in a specific country etc - insert your own use case :-)</p>
<h2 id="collecting-netstat-information-from-hosts">Collecting netstat information from hosts</h2>
<p>In Velociraptor there&rsquo;s an artefact called <code>Windows.Network.Netstat</code>, which pulls an overview of connections done by Windows hosts - just as if we had opened a command line prompt and typed in <code>netstat</code>. That way we can see what the hosts actually connects to at the moment. Below is a picture of the artefact in Velociraptor.</p>
<p><img src="/img/velogeoip/Pasted_image_20220812193744.png" alt=""></p>
<p>Once the hunt has run on the host(s). The output should look like the image below, which is multiple pages long.</p>
<p><img src="/img/velogeoip/Screenshot_2022-08-12_19-40-25.png" alt=""></p>
<h2 id="geolocating-remote-ips">Geolocating remote IPs</h2>
<p>From the picture above we can see that the <code>netstat</code> output shows <code>Raddr.IP</code> which is the remote IP that the host is connecting to.</p>
<p>Looking at an IP and telling where that IP is located in the world can be hard, so to make that easier we can use the GeoLite2 Free database from <a href="https://www.maxmind.com/en/accounts/current/geoip/downloads">Maxmind</a>. This is a database that can match an IP up against ie. country, city or ASN number. In this blog I am going to use the <code>GeoLite2-City.mmdb</code> database.</p>
<p>Now with the database downloaded from GeoLite2, we can go ahead and start using the <code>geoip()</code> function build in to Velociraptor. The function will take a list of IPs and look those up in the MMDB given.</p>
<p><img src="/img/velogeoip/Screenshot_2022-08-12_19-50-52.png" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">count</span>() <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">Count</span>,<span style="color:#66d9ef">Timestamp</span>,Pid,Name,Status,<span style="color:#f92672">`</span>Laddr.IP<span style="color:#f92672">`</span>,<span style="color:#f92672">`</span>Laddr.Port<span style="color:#f92672">`</span>,
</span></span><span style="display:flex;"><span>geoip(ip<span style="color:#f92672">=`</span>Raddr.IP<span style="color:#f92672">`</span>,db<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;C:\\GeoLite2-City.mmdb&#39;</span>).country.<span style="color:#66d9ef">names</span>.en <span style="color:#66d9ef">AS</span> Country,<span style="color:#f92672">`</span>Raddr.IP<span style="color:#f92672">`</span>,<span style="color:#f92672">`</span>Raddr.Port<span style="color:#f92672">`</span>,Fqdn
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> Status <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;ESTAB&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">NOT</span> Country <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;United States&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> Country
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">Count</span>
</span></span></code></pre></div><p>The VQL statement above will use the <code>geoip()</code> function to add country names to the artefacts collected. After that it will look for only <em>ESTABLISHED</em> connections, and filter out connections to the US. It then groups by country and orders by count.</p>
<p>The query gives the following output.</p>
<p><img src="/img/velogeoip/Screenshot_2022-08-12_19-57-20.png" alt="">
<img src="/img/velogeoip/Screenshot_2022-08-12_20-07-46.png" alt="">
As seen above, there are a couple of connections to Ireland, some to Denmark and then some to the UK. This could give a really easy overview off the different countries and IPs that the hosts in the environment are connecting to.</p>
<p><strong>EDIT 13/08/2022:</strong> I&rsquo;ve was asked if its possible to add city and autonomous system number (ASN) to the IP&rsquo;s also, so the VQL below shows how to use the <code>geoip()</code> to add city name. For the ASN number, I&rsquo;ve downloaded the other free Maxmind database <code>GeoLite2-ASN.mmdb</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">Timestamp</span>,Pid,Name,Status,<span style="color:#f92672">`</span>Laddr.IP<span style="color:#f92672">`</span>,<span style="color:#f92672">`</span>Laddr.Port<span style="color:#f92672">`</span>,<span style="color:#f92672">`</span>Raddr.IP<span style="color:#f92672">`</span>,
</span></span><span style="display:flex;"><span>geoip(ip<span style="color:#f92672">=`</span>Raddr.IP<span style="color:#f92672">`</span>,db<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;C:\\GeoLite2-City.mmdb&#39;</span>).country.<span style="color:#66d9ef">names</span>.en <span style="color:#66d9ef">AS</span> Country,geoip(ip<span style="color:#f92672">=`</span>Raddr.IP<span style="color:#f92672">`</span>,db<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;C:\\GeoLite2-City.mmdb&#39;</span>).city.<span style="color:#66d9ef">names</span>.en <span style="color:#66d9ef">AS</span> City,geoip(ip<span style="color:#f92672">=`</span>Raddr.IP<span style="color:#f92672">`</span>,db<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;C:\\GeoLite2-ASN.mmdb&#39;</span>).autonomous_system_organization <span style="color:#66d9ef">AS</span> <span style="color:#f92672">`</span>ASN Org<span style="color:#f92672">`</span>,geoip(ip<span style="color:#f92672">=`</span>Raddr.IP<span style="color:#f92672">`</span>,db<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;C:\\GeoLite2-ASN.mmdb&#39;</span>).autonomous_system_number <span style="color:#66d9ef">AS</span> <span style="color:#f92672">`</span>ASN Number<span style="color:#f92672">`</span>,
</span></span><span style="display:flex;"><span><span style="color:#f92672">`</span>Raddr.Port<span style="color:#f92672">`</span>,Fqdn
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> Status <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;ESTAB&#34;</span>
</span></span></code></pre></div><p><img src="/img/velogeoip/Screenshot_2022-08-13_19-52-43.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>Velociraptor Threathunting - Quick Introduction</title>
            <link>https://fiskeren.github.io/posts/velothreathunt/</link>
            <pubDate>Mon, 04 Jul 2022 11:30:36 +0100</pubDate>
            
            <guid>https://fiskeren.github.io/posts/velothreathunt/</guid>
            <description>&lt;p&gt;In my previous posts, I demonstrated how to use Velociraptor to extract artefacts from dead hosts. However, the real strength of Velociraptor lies in its ability to conduct searches across multiple hosts for artefacts. This is particularly useful when responders are trying to answer questions such as, &amp;ldquo;Are there baddies in the network?&amp;rdquo; &amp;ldquo;How many machines have executable X on them?&amp;rdquo; and &amp;ldquo;Did user X log on to system Y?&amp;rdquo; In this blog post, I will provide a quick introduction to using Velociraptor to address these types of questions.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>In my previous posts, I demonstrated how to use Velociraptor to extract artefacts from dead hosts. However, the real strength of Velociraptor lies in its ability to conduct searches across multiple hosts for artefacts. This is particularly useful when responders are trying to answer questions such as, &ldquo;Are there baddies in the network?&rdquo; &ldquo;How many machines have executable X on them?&rdquo; and &ldquo;Did user X log on to system Y?&rdquo; In this blog post, I will provide a quick introduction to using Velociraptor to address these types of questions.</p>
<h2 id="quick-intro-to-vql">Quick intro to VQL</h2>
<p>All queries the Velociraptor performs are executed using the Velociraptor Query Language, or VQL, which is essentially a simpler version of SQL. Therefore, most people should find it easy to read and learn. For instance, the query below retrieves all columns from the <code>Info()</code> artefacts and presents them to the responder.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> info()
</span></span></code></pre></div><p>The output will resemble something like this:</p>
<p><img src="/img/velothreathunt/20220704115223.png" alt=""></p>
<p>If you perform this across multiple machines using the &lsquo;Hunt Manager&rsquo; in Velociraptor, you can expand the query to get an overview of how many different versions of OS you have. To do this, we will create a hunt using the <code>Generic.Client.Info</code> artefacts and query that across all machines. Once it&rsquo;s done, the information received can be seen in the &lsquo;Notebook&rsquo; tab of the hunt:</p>
<p><img src="/img/velothreathunt/20220704120815.png" alt=""></p>
<p>Now, this will provide a table with a row for each machine, which can be handy. However, if there are 1000 endpoints in the environment, the table may not be very easy to overview. Therefore, let&rsquo;s edit the VQL statement to enhance readability. To do this, press the small edit button at the top of the notebook. The default query will likely resemble something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># Generic.Client.Info/BasicInformation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>(artifact<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Generic.Client.Info/BasicInformation&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">50</span>
</span></span></code></pre></div><p>If we examine the statement, we will observe that the data source is not <code>info()</code>; rather, it is <code>source()</code>. This is because it originates from a hunt collecting artefacts across multiple machines, rather than a single run on one machine.</p>
<p>Now, to get an overview, let&rsquo;s change the VQL statement to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> OS,Platform,PlatformVersion,<span style="color:#66d9ef">count</span>() <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">Count</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> OS
</span></span></code></pre></div><p>The output is that we now have a row for each OS version and a count of how many systems have that OS:</p>
<p><img src="/img/velothreathunt/20220704122946.png" alt=""></p>
<p>As you can see, the VQL language is quite powerful and provides the responder with the ability to quickly collect data or to gain an overview of the data collected from hosts. In fact, all hunts in Velociraptor are actually VQL statements made to query systems for information.</p>
<h2 id="installing-artefacts-from-artifact-exchange">Installing artefacts from &lsquo;Artifact Exchange&rsquo;</h2>
<p>There are many artefacts already built into Velociraptor, but a really neat feature of the entire Velociraptor universe is the <a href="https://docs.velociraptor.app/exchange/">Artifact Exchange</a>. The exchange is a collection of artefacts contributed by the community. This means that if you are using Velociraptor and make an amazing query that is not already part of the standard system, you can submit it to the exchange and share it with everyone else so they can benefit from it and discover even more interesting things in environments.</p>
<p>The &lsquo;Artifact Exchange&rsquo; needs to be imported into the Velociraptor server. This can be done by running the artefact <code>Server.Import.ArtifactExchange</code> directly on the Velociraptor server. Navigate to the &lsquo;Server Artifact&rsquo; menu and create a new collection. From the dropdown menu, select the <code>Server.Import.ArtifactExchange</code> artefact and press launch:</p>
<p><img src="/img/velothreathunt/20220704125408.png" alt="">
<img src="/img/velothreathunt/20220704125501.png" alt=""></p>
<p>All artifacts from the exchange are now imported into the server and can be used in hunts.</p>
<h2 id="hunting">Hunting</h2>
<p>Now that we have scratched the surface of VQL and how to use it in hunts, let’s delve into some of the more powerful applications of hunts and VQL in Velociraptor. This section is a collection of different hunts that I have found useful and would like to share.</p>
<h3 id="finding-renamed-executables">Finding renamed executables</h3>
<p>One thing we often observe in cases is the use of psexec or the utilization of <a href="https://lolbas-project.github.io/">LOLBINs</a>, for example: employing <code>rundll32.exe</code> to execute a dll on the host. Security programs sometimes block these methods to prevent threat actors from executing arbitrary code on the systems, prompting them to discover ingenious ways to evade detection. One such method is copying the executable to another location.</p>
<p>For example, let&rsquo;s say a threat actor is avoiding detection by renaming <code>rundll32.exe</code> to <code>x.exe</code> and moving the renamed file to <code>C:\tmp</code>. To find that using Velociraptor, we can use the artefacts called <code>Windows.Detection.BinaryRename</code>, which will search for executables and compare the binary metadata against a predefined list (which you can add to or remove from):</p>
<p><img src="/img/velothreathunt/20220704131544.png" alt=""></p>
<p>Results:</p>
<p><img src="/img/velothreathunt/20220704131930.png" alt=""></p>
<h3 id="finding-lateral-movement">Finding lateral movement</h3>
<p>A key question in nearly all investigations and hunts is: &lsquo;Where did the threat actor go?&rsquo; To answer this question—or to obtain an indication—we can utilize the artefact <code>Windows.EventLogs-RDPAuth</code>.</p>
<p>Although the name suggests that Velociraptor solely searches for RDP authentications, a closer look at the artifact reveals that its description indicates it also examines common logons, such as types 3, 7, and 10 of event 4624, which are not exclusively associated with RDP authentication.</p>
<p>As you can see, the output can be quite noisy and difficult to grasp an overview of:</p>
<p><img src="/img/velothreathunt/20220704133227.png" alt=""></p>
<p>To narrow down the output, let&rsquo;s edit the VQL statement:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> EventTime,Computer,Channel,EventID,UserName,LogonType,SourceIP,Description,Message,Fqdn <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> ( <span style="color:#f92672">//</span> excluded logons <span style="color:#66d9ef">of</span> the <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">on</span> their own <span style="color:#66d9ef">system</span>
</span></span><span style="display:flex;"><span>(UserName <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;suspect1&#34;</span> <span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">NOT</span> Computer <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;suspect1workstation&#34;</span>) 
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">NOT</span> EventID <span style="color:#f92672">=</span> <span style="color:#ae81ff">4634</span> <span style="color:#f92672">//</span> <span style="color:#66d9ef">less</span> interested <span style="color:#66d9ef">in</span> logoff events
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span> Remove DCs, exchange <span style="color:#66d9ef">and</span> fileserver, since this <span style="color:#66d9ef">is</span> expected <span style="color:#66d9ef">to</span> have alot <span style="color:#66d9ef">of</span> logons
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">NOT</span> (Computer <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;dc&#34;</span> <span style="color:#66d9ef">OR</span> Computer <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;exchange&#34;</span> <span style="color:#66d9ef">OR</span> Computer <span style="color:#f92672">=~</span> <span style="color:#e6db74">&#34;fs1&#34;</span>) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> EventTime
</span></span></code></pre></div><p>The output should be a more concise list of logons to other hosts from the patient zero user account, providing the responder with an easier overview of where to investigate next.</p>
<h3 id="getting-a-list-of-running-processes">Getting a list of running processes</h3>
<p>An important thing to always keep in mind when doing threat hunts and investigations is, &ldquo;What does normal look like?&rdquo; It’s always tough to answer that question as a consultant coming into an environment, but Velociraptor can help provide an overview of what&rsquo;s running on the systems.</p>
<p>To obtain a list of running processes, we can use the artefact <code>Windows.System.Pslist</code>. The output will be quite large, so it makes sense to sort and stack the results.</p>
<p>The following VQL query retrieves the output from the hunt and displays only the unsigned binaries running on the systems:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> Name,Exe,Commandline,Hash.SHA256 <span style="color:#66d9ef">AS</span> SHA256,Authenticode.<span style="color:#66d9ef">Trusted</span>,Username,Fqdn,<span style="color:#66d9ef">count</span>() <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">Count</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> Authenticode.<span style="color:#66d9ef">Trusted</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;untrusted&#34;</span> <span style="color:#f92672">//</span><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">only</span> unsigned binaries
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">AND</span> <span style="color:#66d9ef">NOT</span> Exe <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;C:\\Path\\to\\whitelisted\\binary&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span>Stack <span style="color:#66d9ef">for</span> prevalence
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> Exe
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">Count</span>
</span></span></code></pre></div><h3 id="finding-files-across-the-network">Finding files across the network</h3>
<p>The last artefact I would like to show is how to search for files. This can be useful if we already have a list of known IOCs with filenames that we want to look for, or if we are simply hunting for &lsquo;weird&rsquo; files. To search for files, we can use the <code>Windows.Search.FileFinder</code> artefact.</p>
<p>As an example, let’s search for DLL files in unusual locations that might help us find problematic items. For the SearchFileGlobTable, we will add locations to search for:</p>
<pre tabindex="0"><code>C:\Windows\Tasks\*.dll
C:\Windows\Temp\**\*.dll
C:\*\*.dll
C:\*.dll
</code></pre><p><img src="/img/velothreathunt/20220704140415.png" alt=""></p>
<p>The output can be very noisy, and we will therefore need to sort in the VQL statement to make it a bit easier to read:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> Fqdn,FullPath,MTime <span style="color:#66d9ef">as</span> Modified,BTime <span style="color:#66d9ef">as</span> Created,IsDir, <span style="color:#66d9ef">count</span>() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">Count</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">source</span>() <span style="color:#66d9ef">WHERE</span> IsDir <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;false&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> FullPath
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> <span style="color:#66d9ef">Count</span>
</span></span></code></pre></div><h2 id="summary">Summary</h2>
<p>As you can see, the Velociraptor agent can be used to perform very powerful and quick searches across the entire host landscape, making it easier for threat hunters and others to identify things that are out of the ordinary.</p>
<p>For more information about how to conduct hunts and create queries in VQL, please see the Velociraptor <a href="https://docs.velociraptor.app/">documentation</a>.</p>
<h2 id="credit">Credit</h2>
<p>Sources for this blog post comes from:</p>
<ul>
<li>Stephan Berger <a href="https://twitter.com/malmoeb">twitter</a></li>
<li>Matthew Green <a href="https://twitter.com/mgreen27">twitter</a></li>
<li>Eric Capuano&rsquo;s awesome Velociraptor <a href="https://twitter.com/Recon_InfoSec/status/1538216506483478528?s=20&amp;t=v0fV-l1L9bH8PWKhQXdnKg">video</a> and the <a href="https://gist.github.com/ecapuano/daee6f3704273c2c8b527f522c1725db">Velociraptor notebook</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Creating Standalone Artifact Collector</title>
            <link>https://fiskeren.github.io/posts/creating_collector/</link>
            <pubDate>Tue, 07 Jun 2022 16:30:11 +0100</pubDate>
            
            <guid>https://fiskeren.github.io/posts/creating_collector/</guid>
            <description>&lt;p&gt;I received several positive reactions to my last post about how to perform dead host collections. Therefore, I wanted to follow it up with another post on how to create a standalone collector that can gather artefacts from a running host using Velociraptor.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.velociraptor.app/&#34;&gt;Velociraptor&lt;/a&gt; is an excellent DFIR tool designed to efficiently provide visibility into endpoints. It can operate in a server-agent setup, functioning essentially as an EDR—without the AV, of course—with thousands of hosts. Additionally, it can also serve as a standalone artefact collector.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>I received several positive reactions to my last post about how to perform dead host collections. Therefore, I wanted to follow it up with another post on how to create a standalone collector that can gather artefacts from a running host using Velociraptor.</p>
<p><a href="https://docs.velociraptor.app/">Velociraptor</a> is an excellent DFIR tool designed to efficiently provide visibility into endpoints. It can operate in a server-agent setup, functioning essentially as an EDR—without the AV, of course—with thousands of hosts. Additionally, it can also serve as a standalone artefact collector.</p>
<p>A standalone collector is an executable that is useful in situations where Velociraptor or other types of collection tools are not present in the environment. For instance, an Incident Responder addressing an incident may want to provide the client&rsquo;s sysadmin with a quick way to gather artefacts from a suspicious host without the need for tool deployment.</p>
<h2 id="running-velociraptor-in-gui-mode">Running Velociraptor in GUI mode</h2>
<p>Velociraptor makes it quite easy to create a collector without needing to set up a lot in advance. After downloading the Velociraptor executable from their <a href="https://github.com/Velocidex/velociraptor">github page</a>, we can run the executable using the <code>gui</code> parameter. This will present us with the Velociraptor web page, as if we were running it in server mode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>.\velociraptor-v0.6.<span style="color:#ae81ff">4</span>-<span style="color:#ae81ff">2</span>-windows-amd64.exe gui
</span></span></code></pre></div><p><img src="/img/offlinecollect/20220603171710.png" alt=""></p>
<p>This will also automatically launch the default browser to the Velociraptor web page.</p>
<p><img src="/img/offlinecollect/20220603172257.png" alt=""></p>
<p>We are now ready to create the collector.</p>
<h2 id="creating-standalone-collector">Creating standalone collector</h2>
<p>Once the Velociraptor executable is running in GUI mode, we will be able to use its capabilities to create a standalone collector.</p>
<p>To do this, we will go to the <em>Server Artifacts</em> menu tab and press the small plain paper icon called <em>Create Offline Collector</em>. This will open a menu with the various default artifacts that Velociraptor is capable of collecting from hosts.</p>
<p><img src="/img/offlinecollect/20220603172949.png" alt=""></p>
<p>For this exercise, I will choose <em>Windows.KapeFiles.Targets</em> and <em>Windows.Memory.Acquisition</em>. KAPE is developed by Eric Zimmerman and stands for Kroll Artefact Parser and Extractor, which can collect a wide range of artefacts. Windows.Memory.Acquisition will use WinPmem to gather the memory from the machine.</p>
<p>After selecting <em>Windows.KapeFiles.Targets</em> and <em>Windows.Memory.Acquisition</em>, go to the Configure Parameters tab at the bottom. This will display the two selected artefact modules. Next, select the <em>Windows.KapeFiles.Targets</em> module, which will provide a wide variety of artefacts to collect. I recommend choosing the <em>_SANS_Triage</em> artefact list, as it covers a broad range of artefacts and encompasses most use cases.</p>
<p><img src="/img/offlinecollect/20220603174026.png" alt=""></p>
<p>At the next tab <em>Configure Collection</em>, there are multiple settings that can be configured. Some of the more interesting ones are the <em>Collection</em> Type and <em>Password</em>. The Collection Type offers the following options:</p>
<ul>
<li>Create a zip file locally on the system</li>
<li>Upload the zip file directly to a Google Cloud Bucket</li>
<li>Upload it to an AWS bucket</li>
<li>Upload to an SFTP server</li>
</ul>
<p>This is really smart if we have, for example, a Timesketch setup that automatically manages the uploaded artefacts and creates a timeline in Timesketch.</p>
<p><img src="/img/offlinecollect/20220603174333.png" alt=""></p>
<p>In the <em>Specify resources</em> tab, we can set a limit on the resources used by the Velociraptor collector. By default, the CPU limit is set to 100% and the maximum execution time is 600 seconds. Since we are also collecting memory, this process might take a while, so I recommend setting the maximum execution time a bit higher, e.g., 1200 or 3600 seconds.</p>
<p><img src="/img/offlinecollect/20220603174843.png" alt=""></p>
<p>Once we have completed the different configurations, we can navigate to the <em>Review</em> tab, check the configuration in JSON, and from there proceed to the <em>Launch</em> tab. The <em>Launch</em> tab will verify all prerequisites, including downloading the WinPmem executable from the Velociraptor repository. The great thing about this is that Velociraptor will embed the executable into the Collector executable, so we won&rsquo;t have to deal with multiple executables.</p>
<p>Once everything is green on the <em>Launch</em> tab, we can click the newly created collection and navigate to the <em>Uploaded Files</em> tab, as shown below. Here, we will be able to download the newly created collector executable.</p>
<p><img src="/img/offlinecollect/20220603175002.png" alt=""></p>
<p>We can now transfer this executable to the host we wish to collect from and execute it as an administrator.</p>
<p><img src="/img/offlinecollect/20220603175217.png" alt=""></p>
<p>The collector will open a new window displaying all the different files being collected and will close itself as soon as it has finished collecting. After collecting, we can either copy the zip file to our investigator host or access the uploaded file in our Google/AWS/SFTP bucket.</p>
<p><img src="/img/offlinecollect/20220603175305.png" alt=""></p>
<h2 id="re-configuring-the-collector-executable">Re-configuring the collector executable</h2>
<p>Now, if we have already created an offline collection executable and we want to reconfigure the settings, we can dump the configuration from the collector to YAML, modify the settings in the YAML, and then package it into a new executable.</p>
<p>Extract the configuration from the standalone collector executable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>.\Collector_velociraptor-v0.6.<span style="color:#ae81ff">4</span>-<span style="color:#ae81ff">2</span>-windows-amd64.exe config show &gt; config.yaml
</span></span></code></pre></div><p>Once the YAML file is reconfigured, we can repack the collector using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>.\Collector_velociraptor-v0.6.<span style="color:#ae81ff">4</span>-windows-amd64.exe config repack config.yaml collector_repacked.exe
</span></span></code></pre></div><p>We can also verify the configuration with the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>.\collector_repacked.exe config show
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Deadhost Investigation and Super Timeline</title>
            <link>https://fiskeren.github.io/posts/deadhostinvestigation/</link>
            <pubDate>Sun, 22 May 2022 09:45:02 +0100</pubDate>
            
            <guid>https://fiskeren.github.io/posts/deadhostinvestigation/</guid>
            <description>&lt;p&gt;I recently attended a &lt;a href=&#34;https://www.sans.org/cyber-security-courses/advanced-incident-response-threat-hunting-training/&#34;&gt;SANS 508&lt;/a&gt; course and got time to play around with &lt;a href=&#34;https://docs.velociraptor.app/&#34;&gt;Velociraptor&lt;/a&gt;, which is an awesome DFIR tool made to efficiently get visibility into endpoints. It can be run in a server/agent setup, essentially working as an EDR with thousands of hosts, and it can also be used as a standalone artifact collector.&lt;/p&gt;
&lt;p&gt;In this post, I&amp;rsquo;ll try to explain how to use the Velociraptor executable as a artefact collector to quickly collect Windows artefacts from a dead host image. After collecting the artefacts, I will show how to create a super timeline using &lt;a href=&#34;https://plaso.readthedocs.io/en/latest/sources/user/Using-log2timeline.html&#34;&gt;Plaso log2timeline&lt;/a&gt; from the evidence collected.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>I recently attended a <a href="https://www.sans.org/cyber-security-courses/advanced-incident-response-threat-hunting-training/">SANS 508</a> course and got time to play around with <a href="https://docs.velociraptor.app/">Velociraptor</a>, which is an awesome DFIR tool made to efficiently get visibility into endpoints. It can be run in a server/agent setup, essentially working as an EDR with thousands of hosts, and it can also be used as a standalone artifact collector.</p>
<p>In this post, I&rsquo;ll try to explain how to use the Velociraptor executable as a artefact collector to quickly collect Windows artefacts from a dead host image. After collecting the artefacts, I will show how to create a super timeline using <a href="https://plaso.readthedocs.io/en/latest/sources/user/Using-log2timeline.html">Plaso log2timeline</a> from the evidence collected.</p>
<p>For this blog post I&rsquo;ve used an image from NIST - <a href="https://cfreds.nist.gov/all/NIST/HackingCase">Hacking Case</a>, and mounting the E01 image is done using the <em>Image Mounter</em> tool made by <a href="https://arsenalrecon.com/downloads/">Arsenal Recon</a>.</p>
<p><img src="/img/deadhost/20220521204910.png" alt=""></p>
<p>The Velociraptor executable used is the standard exe downloaded from Velociraptors <a href="https://github.com/Velocidex/velociraptor">Github</a>.</p>
<h2 id="collecting-artifacts">Collecting artifacts</h2>
<p>The Velociraptor executable has multiple built-in collection modules that can be used to collect various artefacts from hosts. In this example I&rsquo;ve chosen to use the Windows.KapeFiles.Targets artefacts collection method. This is created after Eric Zimmermans KAPE (Kroll Artefact Parser and Extractor), and collects a wide range of artefacts. I will be collecting artefacts defined by the built in _SANS_Triage, Notepad and MemoryFiles artefacts lists because this collects <em>most</em> artefacts needed in an investigation. These lists are essentially collections of directory and file names that Velociraptor will search for on the specified host.</p>
<p>The command used us the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>.\velociraptor-v0.6.<span style="color:#ae81ff">4</span>-<span style="color:#ae81ff">2</span>-windows-amd64.exe -v artifacts collect Windows.KapeFiles.Targets --output TriageFile.zip --args Device=<span style="color:#e6db74">&#34;E:&#34;</span> --args KapeTriage=Y --args _SANS_Triage=Y --args Notepad=Y --args MemoryFiles=Y
</span></span></code></pre></div><p>Arguments used:</p>
<ul>
<li><code>artifacts collect Windows.KapeFiles.Targets</code> - Select the collection method <em>Windows.KapeFiles.Targets</em></li>
<li><code>--output TriageFile.zip</code> - Save the files collected to a zip file called TriageFile.zip</li>
<li><code>--args Device=&quot;E:&quot;</code> - The drive letter the E01 is mounted to</li>
<li><code>--args KapeTriage=Y</code> - Collect KapeTriage files</li>
<li><code>--args _SANS_Triage=Y</code> - Collect files defined by the _SANS_Triage list</li>
<li><code>--args Notepad=Y</code> - Collect files defined by the Notepad list</li>
<li><code>--args MemoryFiles=Y</code> - Collect files defined by the MemoryFiles list</li>
</ul>
<p>Executing the commands creates the following output:</p>
<p><img src="/img/deadhost/20220521210410.png" alt=""></p>
<p>After collecting the Veloricaptor executable has now created a file called TriageFile.zip</p>
<p><img src="/img/deadhost/20220521211442.png" alt=""></p>
<h2 id="super-timeline">Super Timeline</h2>
<p>Once the artefacts are collected, Plaso&rsquo;s log2timeline can be used to create a timeline from them. Giving an easy way to triage an image, identifying suspicious activity.</p>
<p>I will be using the docker version of log2timeline, where I mount my local folder to the docker instance as <code>/data</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo docker run -v /path/to/evidence/:/data log2timeline/plaso log2timeline --storage-file /data/host.plaso /data/E
</span></span></code></pre></div><p>The command should give the output as shown below and create a file called <em>host.plaso</em>.</p>
<p><img src="/img/deadhost/20220521214159.png" alt=""></p>
<p>The <em>host.plaso</em> file is the database file created by log2timeline, which can be exported to a CSV file, which can be read using ie. Eric Zimmermans <a href="https://ericzimmerman.github.io/#!index.md">timeline explorer</a>.</p>
<p>Converting the host.plaso file to a CSV file is done using Plaso&rsquo;s psort.py tool.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo docker run -v /path/to/evidence/:/data log2timeline/plaso psort -o l2tcsv -w /data/timeline.csv /data/host.plaso
</span></span></code></pre></div><p>The command gives the output as shown below and creates the file <em>timeline.csv</em>.</p>
<p><img src="/img/deadhost/20220521215255.png" alt=""></p>
<p>Once the CSV is created, it can be loaded in to a tool such as Eric Zimmermans Timeline explorer, which has a very handy preset of colour mapping to easily get an overview of execution, web history and much more. A screenshot of the CSV just created is seen below.</p>
<p><img src="/img/deadhost/20220521215624.png" alt=""></p>
<h2 id="conclusion">Conclusion</h2>
<p>This small blog shows that triaging of a disk can be optimised using tools such as Velociraptor and log2timeline. Instead of running a timeline analysis of a whole disk image, Velociraptor can be used to collect only what is important to create a picture of what happened when and how.</p>
<p>Instead of running log2timeline across all files on a disk, which in some cases can take days, timeline analysis is only being run on the important files collected by the Velociraptor executable and thereby cut down the crunch time (wait time) drasticaly.</p>
]]></content>
        </item>
        
    </channel>
</rss>
